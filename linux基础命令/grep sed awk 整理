
grep是字符串查找工具

sed是流编辑器，可对文本/二进制文件进行：替换/删除/添加操作

awk是文本分析工具，可对文件进行分析处理，尤其适合对文本文件进行数据提取、数据统计、数据比对等等分析处理操作。
对大数据量的文件数据比对尤其令人印象深刻：几百万行的数据对比只要几分钟就能出结果，性能极好。


grep
grep(关键字: 截取) 文本搜集工具, 结合正则表达式非常强大
主要参数 []
-c : 只输出匹配的行
-i : 不区分大小写
-I : 区分大小写
-h : 查询多文件时不显示文件名
-l : 查询多文件时, 只输出包含匹配字符的文件名
-n : 显示匹配的行号及行
-v : 显示不包含匹配文本的所有行(我经常用除去grep本身)
基本工作方式: grep 要匹配的内容 文件名, 例如:
grep 'test' d* 显示所有以d开头的文件中包含test的行
grep 'test' aa bb cc 显示在 aa bb cc 文件中包含test的行
grep '[a-z]\{5}\' aa 显示所有包含字符串至少有5个连续小写字母的串


sed
sed(关键字: 编辑) 以行为单位的文本编辑工具，增加a，删除d，替换（行替换s和字符替换c）

sed可以直接修改档案, 不过一般不推荐这么做, 可以分析 standard input
基本工作方式: sed [-nef] '[动作]' [输入文本]
-n : 安静模式, 一般sed用法中, 来自stdin的数据一般会被列出到屏幕上, 如果使用-n参数后, 只有经过sed处理的那一行被列出来.
-e : 多重编辑, 比如你同时又想删除某行, 又想改变其他行, 那么可以用 sed -e '1,5d' -e 's/abc/xxx/g' filename
-f : 首先将 sed的动作写在一个档案内, 然后通过 sed -f scriptfile 就可以直接执行 scriptfile 内的sed动作 
(没有实验成功, 不推荐使用)
-i : 直接编辑, 这回就是真的改变文件中的内容了, 别的都只是改变显示. (不推荐使用)

动作:
a 新增, a 后面可以接字符串, 而这个字符串会在新的一行出现. (下一行)
c 取代, c 后面的字符串, 这些字符串可以取代 n1,n2之间的行
d 删除, 后面不接任何东西
i 插入, 后面的字符串, 会在上一行出现
p 打印, 将选择的资料列出, 通常和 sed -n 一起运作 sed -n '3p' 只打印第3行
s 取代, 类似vi中的取代, 1,20s/old/new/g

[line-address]q 退出, 匹配到某行退出, 提高效率

[line-address]r 匹配到的行读取某文件 例如: sed '1r qqq' abc , 注意, 写入的文本是写在了第1行的后边, 也就是第2行

[line-address]w file, 匹配到的行写入某文件  例如: sed -n '/m/w qqq' abc , 从abc中读取带m的行写到qqq文件中, 
注意, 这个写入带有覆盖性.


举例:
sed -n '2,4p' abc 打印2到4行,(范围)

sed '/test/a RRRRRRR' abc 将 RRRRRRR 追加到所有的带 test 行的下一行 也有可能通过行 sed '1,5c RRRRRRR' abc

sed '1d' abc 删除 abc 档案里的第一行, 注意, 这时会显示除了第一行之外的所有行, 因为第一行已经被删除了
(实际文件并没有被删除,而只是显示的时候被删除了)

sed -n '1d' abc 什么内容也不显示, 因为经过sed处理的行, 是个删除操作, 所以不现实.

sed '2,$d' abc 删除abc中从第二行到最后一行所有的内容, 注意, $符号正则表达式中表示行末尾, 
但是这里并没有说那行末尾, 就会指最后一行末尾, ^开头, 如果没有指定哪行开头, 那么就是第一行开头

sed '$d' abc 只删除了最后一行, 因为并没有指定是那行末尾, 就认为是最后一行末尾
sed '/test/d' abc 文件中所有带 test 的行, 全部删除

sed '/test/c RRRRRRR' abc 将 RRRRRRR 替换所有带 test 的行, 
当然, 这里也可以是通过行来进行替换, 比如 sed '1,5c RRRRRRR' abc

sed '1,4s/root/user/g' file 字符替换



awk
awk(关键字:分析&处理) 一行一行的分析处理 
awk '条件类型1{动作1}条件类型2{动作2}' filename, awk 也可以读取来自前一个指令的 standard input
相对于sed常常用于一整行处理, awk则比较倾向于一行当中分成数个"字段"(区域)来处理, 默认的分隔符是空格键或tab键
例如:
last -n 5 | awk '{print $1 "\t" $3}' 这里大括号内$1"\t"$3 之间不加空格也可以, 不过最好还是加上个空格, 
另外注意"\t"是有双引号的, 因为本身这些内容都在单引号内

$0 代表整行 $1代表第一个区域, 依此类推

awk的处理流程是:
1. 读第一行, 将第一行资料填入变量 $0, $1... 等变量中
2. 依据条件限制, 执行动作
3. 接下来执行下一行
所以, AWK一次处理是一行, 而一次中处理的最小单位是一个区域

另外还有3个变量, NF: 每一行处理的字段数, NR 目前处理到第几行 FS 目前的分隔符

逻辑判断 > < >= <= == !== , 赋值直接使用=

cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}' 首先定义分隔符为:, 然后判断, 
注意看, 判断没有写在{}中, 然后执行动作, FS=":"这是一个动作, 赋值动作, 不是一个判断, 所以不写在{}中

BEGIN END , 给程序员一个初始化和收尾的工作, BEGIN之后列出的操作在{}内将在awk开始扫描输入之前执行, 
而END{}内的操作, 将在扫描完输入文件后执行.

awk '/test/ {print NR}' abc 将带有test的行的行号打印出来, 注意//之间可以使用正则表达式
awk {}内, 可以使用 if else ,for(i=0;i<10;i++), i=1 while(i<NF)
可见, awk的很多用法都等同于C语言, 比如"\t" 分隔符, print的格式, if, while, for 等等



命令总结
awk
【功能说明】：
        awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。
【语法格式】：
        awk [-F  field-separator]  'commands'  input-file(s)
commands 是真正awk命令，[-F域分隔符是可选的。 input-file(s) 是待处理的文件。
【选项参数】：
参数
说明
-F
分隔符 -F “:” 或-F ‘[:%]’以：和%同时为分隔符
NR
代表行
$1
代表第一列

【实践操作】：
例1：如果只是显示/etc/passwd的账户
#cat /etc/passwd |awk  -F ':'  '{print $1}'  
root
daemon
bin
Sys
这种是awk+action的示例，每行都会执行action{print $1}。
-F指定域分隔符为':'。
例2：三种awk取IP的方法
案例
[root@mob ~]# ifconfig eth0|grep 'inet addr'
          inet addr:192.168.127.132  Bcast:192.168.127.255  Mask:255.255.255.0
方法一：
[root@mob ~]# ifconfig eth0|grep 'inet addr'|awk -F ":" '{print $2}'|awk '{print $1}'
192.168.127.132
方法二：
[root@mob ~]# ifconfig eth0|grep 'inet add'|awk -F '[ :]' '{print $13}'
192.168.127.132
小结：这个方法很方便吧，同学们可以多用，选取包含IP地址行的特殊关键字'inet addr’过滤然后，使用awk以空格和:同时做分隔符，
然后取出需要的内容。
本答案的最大缺点就是计算$n的时候很费劲，因为inet前面有多个空格，查到$13，真是不容易
方法三：
[root@mob ~]# ifconfig eth0|awk -F '[ :]+' 'NR==2 {print $4}'
192.168.127.132
提示：本题NR是行号，分隔符+号匹配，[]里一个或多个任意一个分隔符，这里就是匹配一个或多个冒号或空格。
1）awk -F后面跟分隔符 ‘[空格:]+’ ,其中[空格:]多分隔符写法，意思是以空格或冒号做分隔，后面的"+"号是正则表达式，
意思是匹配前面空格或冒号，两者之一的1个或1个以上。
2）NR==2和sed -n "2p",相当，意思都是选择第几行,例：
[root@oldboy ~]# ifconfig eth0|awk NR==2
inet addr:10.0.0.185 Bcast:10.0.0.255 Mask:255.255.255.0
3）指定awk -F '[ :]+'分隔符后，不同字符串被分隔的列依次为：
[size=10.5000pt]
inet
addr
10.0.0.185
Bcast:10.0.0.255 Mask:255.255.255.0
第一列
第二列
第三列
第四列
后面忽略不计。
4）整个答案awk部分意思是，通过NR==2取出第二行，然后，通过-F '[-:]+多分隔符正则匹配，然后通过｛print $4｝打印出第四列
